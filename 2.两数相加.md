# 2.两数之和

###### 给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。

###### 请你将两个数相加，并以相同形式返回一个表示和的链表。

###### 你可以假设除了数字 0 之外，这两个数都不会以 0 开头。



自己的解法就比较常规，主要是知道的如何在leetcode上用struct内定义的函数。就当作普通函数用函数名调用即可，不需要写作用域。本题中结构体内都是构造函数。

要考虑边界条件，比如遍历完成后进位仍为1，则需要把最后一个节点数值补全。
另一个错误是忘记，在一般情况下，需要把提前申请的节点释放。

```C++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode* result = new ListNode();
        ListNode* pre = result;
        ListNode* next = result;
        int co = 0;
        while(l1 && l2)
        {
            pre = next;
            int a = l1->val;
            int b = l2->val;
            int sum = a+b+co;
            co = sum/10;
            next -> val = sum%10;
            ListNode * t = new ListNode();
            next->next = t;
            next = t;

            l1 = l1->next;
            l2 = l2->next;
        }
        while(l1)
        {
            pre = next;
            int a = l1->val;
            int sum = a+co;
            co = sum/10;
            next -> val = sum%10;
            ListNode * t = new ListNode();
            next->next = t;
            next = t; 

            l1 = l1->next;
        }
        while(l2)
        {
            pre = next;
            int b = l2->val;
            int sum = b+co;
            co = sum/10;
            next -> val = sum%10;
            ListNode * t = new ListNode();
            next->next = t;
            next = t; 

            l2 = l2->next;
        }
        if(co)  //边界条件
        {
            next->val = 1;
        }
        else
        {
            pre->next = NULL;
            delete next;
        }

        return result;
    }
};
```





# 其他解法

很妙的while**循环条件**的写法和**移动指针**的写法

```C++
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        // 使用prenode而不需要单独考虑头节点，以简化代码
        ListNode *prenode = new ListNode(0);
        ListNode *lastnode = prenode;
        int val = 0;
        while(val || l1 || l2) {
            val = val + (l1?l1->val:0) + (l2?l2->val:0);
            lastnode->next = new ListNode(val % 10);
            lastnode = lastnode->next;
            val = val / 10;
            l1 = l1?l1->next:nullptr;
            l2 = l2?l2->next:nullptr;
        }
        ListNode *res = prenode->next;
        delete prenode; // 释放额外引入的prenode
        return res;
    }
};

作者：xiao-lin-20
链接：https://leetcode-cn.com/problems/add-two-numbers/solution/cjie-ti-de-wan-zheng-dai-ma-bao-gua-sheng-cheng-ce/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

递归(感觉就是另一种形式的while循环，但想不到orz)

```C++
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        return dfs(l1, l2, 0);
    }

    ListNode* dfs(ListNode* l, ListNode* r, int i) {
        if (!l && !r && !i) return nullptr;
        int sum = (l ? l->val : 0) + (r ? r->val : 0) + i;
        ListNode* node = new ListNode(sum % 10);
        node->next = dfs(l ? l->next : nullptr, r ? r->next : nullptr, sum / 10);
        return node;
    } 
};

作者：dnanki
链接：https://leetcode-cn.com/problems/add-two-numbers/solution/di-gui-si-lu-jian-dan-dai-ma-duan-by-dnanki/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

